---
layout: post
title: 从0开始学架构_笔记_2
category: 技术
keywords: 架构
---

## 高性能数据库集群
  * 读写分离
    - 本质是将访问压力分散到集群中的多个节点，但是没有分散存储压力
    - 数据库服务器搭建主从集群，一主一从、一主多从都可以
    - 设计复杂度
      - 主从复制延迟
        - 解决主从复制延迟有几种常见的方法
          - 写操作后的读操作指定发给数据库主服务器
          - 读从机失败后再读一次主机
            - 黑客暴力破解账号，会导致大量的二次读取操作，主机可能顶不住读操作的压力从而崩溃
          - 关键业务读写操作全部指向主机，非关键业务采用读写分离
      - 分配机制
        - 程序代码封装
          - 在代码中抽象一个数据访问层（所以有的文章也称这种方式为“中间层封装”），实现读写操作分离和数据库服务器连接的管理
          - 目前开源的实现方案中，淘宝的 TDDL（Taobao Distributed Data Layer，外号: 头都大了）是比较有名的。
        - 中间件封装
         - 中间件封装指的是独立一套系统出来，实现读写操作分离和数据库服务器连接的管理。中间件对业务服务器提供 SQL 兼容的协议，业务服务器无须自己进行读写分离。对于业务服务器来说，访问中间件和访问数据库没有区别，事实上在业务服务器看来，中间件就是一个数据库服务器。
         - 目前的开源数据库中间件方案中，MySQL 官方推荐 MySQL Router
  * 分库分表
    - 既可以分散访问压力，又可以分散存储压力
    - 什么时候引入分库分表是合适的？
      - 先做数据库服务器的调优操作，例如增加索引，oracle有很多的参数调整;
      - 引入缓存技术，例如Redis，减少数据库压力
      - 程序与数据库表优化，重构，例如根据业务逻辑对程序逻辑做优化，减少不必要的查询;
      - 在这些操作都不能大幅度优化性能的情况下，不能满足将来的发展，再考虑分库分表，也要有预估性
    - 业务分库
      - join 操作问题
        - 业务分库后，原本在同一个数据库中的表分散到不同数据库中，导致无法使用 SQL 的 join 查询
     - 事务问题
       - 原本在同一个数据库中不同的表可以在同一个事务中修改，业务分库后，表分散到不同的数据库中，无法通过事务统一修改。虽然数据库厂商提供了一些分布式事务的解决方案（例如，MySQL 的 XA），但性能实在太低，与高性能存储的目标是相违背的。
     - 成本问题
     - 基于上述原因，对于小公司初创业务，并不建议一开始就这样拆分
    - 分表
      - 对单表数据进行拆分
      - 垂直拆分，表记录数相同但包含不同的列
        - 垂直分表适合将表中某些不常用且占了大量空间的列拆分出去
        - 垂直分表引入的复杂性主要体现在表操作的数量要增加。例如，原来只要一次查询就可以获取 name、age、sex、nickname、description，现在需要两次查询，一次查询获取 name、age、sex，另外一次查询获取 nickname、description。
      - 水平拆分，表的列相同但包含不同的行数据
       - 水平分表适合表行数特别大的表
       - 水平分表相比垂直分表，会引入更多的复杂性，主要表现在下面几个方面
         - 路由
           - 水平分表后，某条数据具体属于哪个切分后的子表，需要增加路由算法进行计算，这个算法会引入一定的复杂性。
           - 常见路由算法：
             - 范围路由
             - Hash路由
             - 配置路由
               - 配置路由就是路由表，用一张独立的表来记录路由信息。
               - 配置路由设计简单，使用起来非常灵活，尤其是在扩充表的时候，只需要迁移指定的数据，然后修改路由表就可以了。
               - 配置路由的缺点就是必须多查询一次，会影响整体性能；而且路由表本身如果太大（例如，几亿条数据），性能同样可能成为瓶颈，如果我们再次将路由表分库分表，则又面临一个死循环式的路由算法选择问题。
         - Join操作
           -  水平分表后，数据分散在多个表中，如果需要与其他表进行 join 查询，需要在业务代码或者数据库中间件中进行多次 join 查询，然后将结果合并。
         - count()操作
           - 常见的处理方式有下面两种：
             - count() 相加：具体做法是在业务代码或者数据库中间件中对每个表进行 count() 操作，然后将结果相加。这种方式实现简单，缺点就是性能比较低。
             - 记录数表：具体做法是新建一张表，假如表名为“记录数表”，包含 table_name、row_count 两个字段，每次插入或者删除子表数据成功后，都更新“记录数表”。
         - order by操作
           - 水平分表后，数据分散到多个子表中，排序操作无法在数据库中完成，只能由业务代码或者数据库中间件分别查询每个子表中的数据，然后汇总进行排序。
       - 实现方法
         - 和数据库读写分离类似，分库分表具体的实现方式也是“程序代码封装”和“中间件封装”，但实现会更复杂。读写分离实现时只要识别 SQL 操作是读操作还是写操作，通过简单的判断 SELECT、UPDATE、INSERT、DELETE 几个关键字就可以做到，而分库分表的实现除了要判断操作类型外，还要判断 SQL 中具体需要操作的表、操作函数（例如 count 函数)、order by、group by 操作等，然后再根据不同的操作进行不同的处理。例如 order by 操作，需要先从多个库查询到各个库的数据，然后再重新 order by 才能得到最终的结果。

## 高性能NoSQL
  * 大
